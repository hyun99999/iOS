# iOS
SWIFT 스위프트 프로그래밍 3판 swift5 /야곰 지음
을 읽고 공부한 내용을 정리 중

:umbrella: iOS 공부


1/1(금)

ch9.구조체와 클래스
- 구조체
- 클래스


1/2(토)

ch10.프로퍼티와 메서드
- 프로퍼티
  - 저장 프로퍼티
  - 지연 저장 프로퍼티
  - 프로퍼티 감시자
  - 연산 프로퍼티
  - 타입 프로퍼티
    - 저장 타입 프로퍼티
    - 연산 타입 프로퍼티
- 메서드
  - 인스턴스 메서드
    - mutating
    - self 프로퍼티
  - 타입 메서드
  
ch11. 인스턴스 생성 및 소멸
  - 이니셜라이저
  - 옵셔널 프로퍼티 타입
  - 기본 이니셜라이저와 멤버와이즈 이니셜라이저(클래스x)
  - 초기화 위임
  - failable initializer
  - deinitializer(클래스o)

ch12. 접근제어
  - open
  - public
  - internal
  - fileprivate
  - private

1/3(일)

ch13.클로저
> 장점은 간단한 표현. 함수는 클로저의 일종. 기본적을 비탈출 클로저
  - 기본 클로저
  - 후행 클로저
    > 기본 클로저를 조금 더 읽기 쉽게 바꾼 것. 함수나 메서드의 소괄호를 닫은 후 작성해도 됨.
  - 클로저 표현 간소화
    - 문맥을 이용한 타입 유추
      > 이미 적합한 타입을 준수하고있다고 유추 -> 클로저의 매개변수 타입과 반환 타입을 생략하여 표혀 가능.
    - 단축 인자 이름
      > 첫 번째 전달인자부터 $0,$1,$2 ... 순서로 표현. 키워드 in 사용필요x
    - 암시적 반환 표현
      > return 생략.
    - 연산자 함수
      > 연산자 함수를 클로저의 함수 사용
    - 탈출 클로저
      > @escaping 통해서 비동기 작업으로 함수 종료되고 난 후 호출할 필요있는 클로저를 사용해야할 때.
      > 함수 외부에 정의된 변수나 상수에 저장되어 함수가 종료된 후 사용할 수 있다.
    - auto closure
      > 자동 클로저는 전달인자를 갖지 않는다. @autoclosure 기본적을 비탈출 클로저.
      > 함수의 전달인자로 전달하는 표현을 자동으로 변환해주는 클로저.
 
 ch14.옵셔널 체이닝과 빠른 종료
  - 옵셔널 체이닝
    > 옵셔널에 속해 있는 nil 일지도 모르는 프로퍼티, 메서드, 서브스크립션 등을 가져오거나 호출할 때 사용할 수 있는 일련의 과정.
    > 한 단계뿐만 아니라 여러 단계로 복잡하게 중첩된 옵셔널 프로퍼티나 메서드 등에 매번 nil 체크를 하지 않아도 손쉽게 접근 가능. 할당도 가능.
    > 옵셔널 바이닝을 통해 결과값이 nil 이 아님을 확인하는 동시에 값을 받아올 수 있음.
  - 빠른 종료
    ```swift
    guard ... else {}
    ```
    > 특정 조건에 부합하지 않다는 판단이 되면 빠르게 코드 블록의 실행을 종료 가능.
    > 코드 종료할 때는 
    ```swift
    return, break, continue, throw 
    ```
    > 등의 제어문 전환 명령을 사용.

1/4(월)

ch15.맵,필터,리듀스
  - Map맵
    > 자신을 호출할 때 매개변수로 전달된 함수를 실행하여 그 결과를 다시 반해주는 함수.
    > 컨테이너가 담고 있던 각각의 값을 매개변수를 통해 받은 함수에 적용한 후 다시 컨테이너에 포장하여 반환. 이때 새로운 컨테이너가 생성되어 반환.
    > 클로저 표현식을 사용해서 간략화 가능. 배열, 딕셔너리, 세트, 옵셔널 등에서 사용 가능.
  - Filter필터
    > 컨테이너 내부의 값을 걸러서 추출하는 역할. 맵과 마찬가지로 새로운 컨테이너에 값을 담아 반환.
    > 맵과 필터를 체인처럼 연결하여 사용 가능.
  - Reduce리듀스
    > 컨테이너 내부의 콘텐츠를 하나로 합하는 기능을 실행하는 고차함수.
    > 첫번째 형태는 클로저가 각 요소를 전달 받아 연산한 후 값을 다음 클로저 실행을 위해 반환하며 컨테이너를 순환하는 형태.
    > 두번재 형태는 클로저가 따로 결과값을 반환하지 않는 형태. 대신 inout 매개변수를 사용하여 초기값에 직접 연산을 실행.

ch16.모나드
  - 컨텍스트
    > 옵셔널이 여기 해당. 컨텐츠를 담고있다.
  - 함수객체
    > 맵을 적용할 수 있는 컨테이너 타입. Array, Dictionary, Set 등.
  - 모나드
    - flatMap
      > Map 과 다르게 컨텍스트 내부의 컨텍스트를 모두 같은 위상으로 평평하게 펼쳐준다는 의미.
    ```swift
    func map<U>(_ transform: (Wrapped) throws -> U) rethrows -> U?
    func flatMap<U>(_ tranform: (Wrapped) throws -> U?) rethrows -> U?
    ```
      > flatMap 은 클로저를 실행하면 알아서 내부 컨테이너까지 값을 추출.
      > flatMap 은 .none 이되거나 nil 이 되는 등에는 별도의 예외처리없이 빈 컨테이너를 반환.

1/6()

ch17.서브스크립트 문법
  > 인스턴스의 이름 뒤에 대괄호로 감싼 값으 써줌으로써 인스턴스 내부의 특정값에 접근 가능.
  > 하나의 타입이 여러개의 서브스크립트를 가질 수도 있다. 
  ```swift
  //서브스크립트 정의 문법
  subscript(... : ...) -> ... {}
  //사용
  instance[]
  ```
  - 타입 서브스크립트
    > 인스턴스가 아닌 타입 자체에서 사용할 수 있는 서브스크립트. subscript 키워드 앞에 static 키워드 추가. 클래스의 경우 class 키워드 사용가능(상속 시 재정의 가능.)

ch18.상속
  - 상속
  - 재정의 override
    - 메서드 재정의
    - 프로퍼티 재정의
      > 프로퍼티를 재정의한다는 것은 프로퍼티 자체가 아니라 프로퍼티의 접근자, 설정자, 프로퍼티 감시자 등을 재정의하는 것.
      > 읽기 전용 프로퍼티였더라도 자식클래스에서 읽기쓰기 가능한 프로퍼티로 재정의 가능. 읽기쓰기 가능한 프로퍼티는 읽기 전용으로 재정의 불가.
      > 프로퍼티 감시자를 재정의하더라도 조상클래스에 정의한 프로퍼티 감시자도 동작.
      > 재정의 방지
      ```swift
      final ~
      ```
  - 클래스의 이니셜라이저
    - 지정 이니셜라이저(designated initializer)
      > 이니셜라이저가 정의된 클래스의 모든 프로퍼티를 초기화해야 하는 의무가짐. 
      ```swift
      init(매개변수들) {
        초기화구문
        }
      ```
    - 편의 이니셜라이저(convenience initializer)
      > 지정 이니셜라이저를 자신 내부에서 호출한다.
      ```swift
      convenience init(매개변수들) {
      초기화구문
      }
      ```
    -  2단계 초기화를 위해서 네가지 안전확인을 진행한다.
      > 1. 자식 클래스의 지정 이니셜라이저가 부모클래스의 이니셜라이저를 호출하기 전에 자신의 프로퍼티를 모두 초기화했는지 확인.
      > 2. 자식클래스의 지정 이니셜라이저는 상속받은 프로퍼티에 값을 할당하기 전에 반드시 부모클래스의 이니셜라이저를 호출.
      > 3. 편의 이니셜라이저는 자신의 클래스에 정의한 프로퍼티를 포함하여 그 어떤 프로퍼티라도 값을 할당하기 전에 다른 이니셜라이저를 호출해야 합니다.
      > 4. 초기화 1단계를 마치기 전까지는(상속 체인을 따라 최상위 클래스까지의 모든 저장 프로퍼티에 값이 있다고 확인하는 것) 이니셜라이저는 인스턴스 메서드를 호출할 수 없다. 또 , 인스턴스 프로퍼티의 값을 읽어들일 수도 없다. self 프로퍼티를 자신의 인스턴스를 나타내는 값으로 활용할 수도 없다.
    - 이니셜라이저 상속 및 재정의
      - 자식클래스의 편의 이니셜라이저가 부모클래스의 지정 이니셜라이저를 재정의하는 경우 override 를 붙인다.
      - 자식클래스에서 부모클래스의 편의 이니셜라이저는 절대로 호출 할 수 없기때문에 이때는 override 붙이지 않는다.
    - 이니셜라이저 자동 상속
      - 특정 조건에서 부모의 이니셜라이저가 자동으로 상속된다. 사실 기본적으로 상속받은 이니셜라이저는 자식클래스에 최적화되어 있지 않아서 스위프트에서는 상속받지 않는다. 하지만 대부분의 경우 자식클래스에서 이니셜라이저를 재정의해줄 필요가 없다.
      - 자식클래스에서 프로퍼티 기본값을 모두 제공한다고 가정할때.
        - 규칙1 : 자식클래스에서 별도의 지정 이니셜라이저를 구현하지 않는다면 부모클래스의 지정 이니셜라이저가 자동으로 상속.
        - 규칙2 : 만약 규칙1 에 따라  자식클래스에서 부모클래스의 지정 이니셜라이저를 자동으로 상속받은 경우 또는 부모클래스의 지정 이니셜라이저를 모두 재정의하여 부모클래스와 동일한 지정 이니셜라이저를 모두 사용할 수 있는 상황이라면 부모클래스의 편의 이니셜라이저가 모두 자동 상속.
    - 요구 이니셜라이저
      ```swift
      required init() {}
       ```
       > 클래스의 이니셜라이저 앞에 명시해주면 상속받는 자식클래스에서 반드시 해당 이니셜라이저를 구현해주어야 합니다. 하지만 자동 상속 가능.
       > 재정의됨과 동시에. 편의 이니셜라이저임과 동시에 요구 이니셜라이저도 가능. required 만 앞에 붙이면 된다.







 
